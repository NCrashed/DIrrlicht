// Copyright (C) 2002-2013 Nikolaus Gebhardt
// This file is part of the "Irrlicht Engine" for the D programming language.
// For conditions of distribution and use, see copyright notice in irrlicht.d module.
module irrlicht.os;

import irrlicht.ILogger;
import irrlicht.ITimer;
import irrlicht.io.path;
import std.datetime;
import std.bitmanip;
import std.random;
import std.stdio;
import core.time;

/**
*	Deprecated: This is no need in this namespace, 
*	use std.bitmanip.swapEndian
*/
deprecated struct Byteswap
{
	static:

	T byteswap(T)(T num)
		if( is(T == ushort) ||
			is(T == short) ||
			is(T == uint) ||
			is(T == int) ||
			is(T == float))
	{
		return swapEndian(num);
	}

	// prevent accidental swapping of chars
	T byteswap(T)(T num)
		if( is(T == ubyte) ||
			is(T == byte))
	{
		return num;
	}
}

version(Windows)
{
	import core.sys.windows.windows;
}

struct Printer
{
	static:

	// prints out a string to the console out stdout or debug log or whatever
	void print(string message)
	{
		version(Windows)
		{
			OutputDebugStringW((message + "\n").toStringz());
		} 
		else
		{
			writeln(message);
		}
	}

	void log(string message, ELOG_LEVEL ll = ELOG_LEVEL.ELL_INFORMATION)
	{
		if(Logger !is null)
			Logger.log(message, ll);
	}

	void log(wstring message, ELOG_LEVEL ll = ELOG_LEVEL.ELL_INFORMATION)
	{
		if(Logger !is null)
			Logger.log(message, ll);
	}

	void log(string message, string hint, ELOG_LEVEL ll = ELOG_LEVEL.ELL_INFORMATION)
	{
		if(Logger !is null)
			Logger.log(message, hint, ll);
	}

	void log(string message, const Path hint, ELOG_LEVEL ll = ELOG_LEVEL.ELL_INFORMATION)
	{
		if(Logger !is null)
			Logger.log(message, hint, ll);
	}

	ILogger Logger = null;
}

struct Randomizer
{
	static:

	/// resets the randomizer
	void reset(uint value = 0x0f0f0f0f)
	{
		seed = value;
		rnd.seed(value);
	}

	/// generates a pseudo random number in the range 0..randMax()
	uint rand()
	{
		auto val = rnd.front();
		rnd.popFront();
		return val;
	}

	/// generates a pseudo random number in the range 0..1
	float frand()
	{
		return rand()*(1.0f/rnd.max);
	}

	/// get maxmimum number generated by rand()
	uint randMax()
	{
		return rnd.max;
	}

	private
	{
		int seed;
		immutable int m = 2147483399; 	// a non-Mersenne prime
		immutable int a = 40692;		// another spectral success story

		alias IrrMinstdRand = LinearCongruentialEngine!(uint, a, 0, m);
		IrrMinstdRand rnd;
	}
}

struct Timer
{
	static:

	/// returns the current time in milliseconds
	uint getTime()
	{
		if(isStopped())
			return LastVirtualTime;

		return LastVirtualTime + cast(uint)((StaticTime - StartRealTime) * VirtualTimerSpeed);
	}

	/// get current time and date in calendar form
	ITimer.RealTimeDate getRealTimeAndDate()
	{
		auto timeinfo = Clock.currTime();

		ITimer.RealTimeDate date;
		date.Hour = cast(uint)timeinfo.hour();
		date.Minute = cast(uint)timeinfo.minute();
		date.Second = cast(uint)timeinfo.second();
		date.Day = cast(uint)timeinfo.day();
		date.Month = cast(uint)timeinfo.month();
		date.Year = cast(uint)timeinfo.year();
		date.Weekday = cast(ITimer.EWeekday)timeinfo.dayOfWeek();
		date.Yearday = cast(uint)timeinfo.dayOfYear();
		date.IsDST = timeinfo.timezone.hasDST();

		return date;
	}

	/// initializes the real timer
	void initTimer(bool usePerformanceTimer=true)
	{
		initVirtualTimer();
	}

	/// sets the current virtual (game) time
	void setTime(uint time)
	{
		StaticTime = getRealTime();
		LastVirtualTime = time;
		StartRealTime = StaticTime;
	}

	/// stops the virtual (game) timer
	void stopTimer()
	{
		if (!isStopped())
		{
			// stop the virtual timer
			LastVirtualTime = getTime();
		}

		--VirtualTimerStopCounter;
	}

	/// starts the game timer
	void startTimer()
	{
		++VirtualTimerStopCounter;

		if (!isStopped())
		{
			// restart virtual timer
			setTime(LastVirtualTime);
		}
	}

	/// sets the speed of the virtual timer
	void setSpeed(float speed)
	{
		setTime(getTime());

		VirtualTimerSpeed = speed;
		if (VirtualTimerSpeed < 0.0f)
			VirtualTimerSpeed = 0.0f;
	}

	/// gets the speed of the virtual timer
	float getSpeed()
	{
		return VirtualTimerSpeed;
	}

	/// returns if the timer currently is stopped
	bool isStopped()
	{
		return VirtualTimerStopCounter < 0;
	}

	/// makes the virtual timer update the time value based on the real time
	void tick()
	{
		StaticTime = getRealTime();
	}

	/// returns the current real time in milliseconds
	uint getRealTime()
	{
		return cast(uint)TickDuration.currSystemTick().msecs;
	}

	private
	{
		void initVirtualTimer()
		{
			StaticTime = getRealTime();
			StartRealTime = StaticTime;
		}

		float VirtualTimerSpeed = 1.0f;
		int VirtualTimerStopCounter = 0;
		uint StartRealTime = 0;
		uint LastVirtualTime = 0;
		uint StaticTime = 0;
	}
}